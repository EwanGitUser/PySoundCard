<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Overview &mdash; PySoundIO 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PySoundIO 0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">PySoundIO 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Overview</a><ul>
<li><a class="reference internal" href="#pysoundio">PySoundIO</a><ul>
<li><a class="reference internal" href="#usage">Usage</a><ul>
<li><a class="reference internal" href="#read-write-mode">Read/Write Mode</a></li>
<li><a class="reference internal" href="#callback-mode">Callback Mode</a></li>
<li><a class="reference internal" href="#when-to-use-read-write-mode-or-callback-mode">When to use Read/Write Mode or Callback Mode</a></li>
<li><a class="reference internal" href="#performance">Performance</a></li>
<li><a class="reference internal" href="#the-name">The Name</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-pysoundio">Module Documentation</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pysoundio">
<h2>PySoundIO<a class="headerlink" href="#pysoundio" title="Permalink to this headline">¶</a></h2>
<p>PySoundIO is an audio library based on PortAudio, CFFI and NumPy</p>
<p>PySoundIO can play and record audio data. Audio devices are supported
through <a class="reference external" href="http://www.portaudio.com/">PortAudio</a>, which is a free, cross-platform, open-source audio
I/O library that runs on may platforms including Windows, OS X, and
Unix (OSS/ALSA). It is accessed through <a class="reference external" href="http://cffi.readthedocs.org/">CFFI</a>, which is a foreign
function interface for Python calling C code. CFFI is supported for
CPython 2.6+, 3.x and PyPy 2.0+. PySoundIO represents audio data as
NumPy arrays.</p>
<p>PySoundIO is inspired by <a class="reference external" href="http://people.csail.mit.edu/hubert/pyaudio/">PyAudio</a>. Its main difference is that it uses
CFFI instead of a CPython extension and tries to implement a more
pythonic interface. Its performance characteristics are very similar.</p>
<div class="line-block">
<div class="line">PySoundIO is BSD licensed.</div>
<div class="line">(c) 2013, Bastian Bechtold</div>
</div>
<div class="section" id="usage">
<h3>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h3>
<p>The basic building block of audio input/output in PySoundIO are
streams. Streams represent sound cards, both for audio playback and
recording. Every stream has a sample rate, a block size, an input
device and/or an output device.</p>
<p>A stream can be either full duplex (both input and output) or half
duplex (either input or output). This is determined by specifying one
or two devices for the stream. Both devices must be part of the same
audio API.</p>
<p>There are two modes of operation for streams: read/write and callback
mode.</p>
<div class="section" id="read-write-mode">
<h4>Read/Write Mode<a class="headerlink" href="#read-write-mode" title="Permalink to this headline">¶</a></h4>
<p>In read/write mode, two methods are used to play/record audio: For
playback, you <tt class="docutils literal"><span class="pre">write()</span></tt> to a stream. For recording, you <tt class="docutils literal"><span class="pre">read()</span></tt>
from a stream. You can read/write up to one block of audio data to a
stream without having to wait for it to play.</p>
<p>Here is an example for a program that records a block of audio and
immediately plays it back:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pysoundio</span> <span class="kn">import</span> <span class="n">Stream</span>

<span class="sd">&quot;&quot;&quot;Loop back five seconds of audio data.&quot;&quot;&quot;</span>

<span class="n">fs</span> <span class="o">=</span> <span class="mi">44100</span>
<span class="n">block_length</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="n">block_length</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="mi">5</span><span class="o">/</span><span class="n">block_length</span><span class="p">)):</span>
    <span class="n">s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">block_length</span><span class="p">))</span>
<span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p>Here is another example that reads a wave file and plays it back:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.io.wavfile</span> <span class="kn">import</span> <span class="n">read</span> <span class="k">as</span> <span class="n">wavread</span>
<span class="kn">from</span> <span class="nn">pysoundio</span> <span class="kn">import</span> <span class="n">Stream</span>

<span class="sd">&quot;&quot;&quot;Play an audio file.&quot;&quot;&quot;</span>

<span class="n">fs</span><span class="p">,</span> <span class="n">wave</span> <span class="o">=</span> <span class="n">wavread</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">wave</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">15</span> <span class="c"># normalize -max_int16..max_int16 to -1..1</span>

<span class="n">block_length</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="n">block_length</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="callback-mode">
<h4>Callback Mode<a class="headerlink" href="#callback-mode" title="Permalink to this headline">¶</a></h4>
<p>In callback mode, a callback function is defined, which will be called
asynchronously whenever there is a new block of audio data available
to read or write. The callback function must then provide/consume one
block of audio data.</p>
<p>Here is an equivalent example to the loopback example earlier. As you
can see, the control flow continues normally after <tt class="docutils literal"><span class="pre">s.start()</span></tt> while
the callback is running in a different thread. This is very useful for
synthesizers or filter-like audio effects.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pysoundio</span> <span class="kn">import</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">continue_flag</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="sd">&quot;&quot;&quot;Loop back five seconds of audio data.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">in_data</span><span class="p">,</span> <span class="n">frame_count</span><span class="p">,</span> <span class="n">time_info</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">in_data</span><span class="p">,</span> <span class="n">continue_flag</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="mi">44100</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p>However, callback mode is somewhat burdensome for playing back audio
data from a file. Note how the callback now has to split up the audio
data into blocks and stop the stream when there is no more data
available.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.io.wavfile</span> <span class="kn">import</span> <span class="n">read</span> <span class="k">as</span> <span class="n">wavread</span>
<span class="kn">from</span> <span class="nn">pysoundio</span> <span class="kn">import</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">continue_flag</span><span class="p">,</span> <span class="n">complete_flag</span>

<span class="sd">&quot;&quot;&quot;Play an audio file.&quot;&quot;&quot;</span>

<span class="n">fs</span><span class="p">,</span> <span class="n">wave</span> <span class="o">=</span> <span class="n">wavread</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">wave</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">15</span> <span class="c"># normalize -max_int16..max_int16 to -1..1</span>
<span class="n">play_position</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">in_data</span><span class="p">,</span> <span class="n">frame_count</span><span class="p">,</span> <span class="n">time_info</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">play_position</span>
    <span class="n">out_data</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="n">play_position</span><span class="p">:</span><span class="n">play_position</span><span class="o">+</span><span class="n">block_length</span><span class="p">]</span>
    <span class="n">play_position</span> <span class="o">+=</span> <span class="n">block_length</span>
    <span class="k">if</span> <span class="n">play_position</span><span class="o">+</span><span class="n">block_length</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">out_data</span><span class="p">,</span> <span class="n">continue_flag</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">out_data</span><span class="p">,</span> <span class="n">complete_flag</span><span class="p">)</span>

<span class="n">block_length</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="n">block_length</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">while</span> <span class="n">s</span><span class="o">.</span><span class="n">is_active</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="when-to-use-read-write-mode-or-callback-mode">
<h4>When to use Read/Write Mode or Callback Mode<a class="headerlink" href="#when-to-use-read-write-mode-or-callback-mode" title="Permalink to this headline">¶</a></h4>
<p>In general, callback mode is the more flexible and powerful way of
using PySoundIO. However, it is more complex and less performant.
Many applications will require callback mode because of its threading.
Also, it is very simple to write filter-like audio effects in callback
mode since audio input and output are readily available.</p>
<p>Many simple tasks, such as playing or recording a chunk of audio data
are more easily accomplished using read/write mode though. Also,
read/write runs somewhat faster and can produce/consume raw data if
requested.</p>
<p>If no data is read/written while in Read/Write mode, recordings are
simply discarded and silence is played. In callback mode, it is an
error not to provide audio data in the callback. Use <tt class="docutils literal"><span class="pre">numpy.zeros()</span></tt>
if you want to play silence.</p>
</div>
<div class="section" id="performance">
<h4>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h4>
<p>PySoundIO uses the CFFI library internally. Performance is a big goal
for the project. On a reasonably recent Apple computer, block sizes of
two or four samples should be no problem at a sampling rate of 44100
or 48000 Hz.</p>
<p>However, performance is strongly influenced by the API in use. Also,
some combinations of audio devices can be problematic even if they are
part of the same API. In general, try to open full duplex streams only
on input/output devices of the same physical sound card for maximum
performance.</p>
</div>
<div class="section" id="the-name">
<h4>The Name<a class="headerlink" href="#the-name" title="Permalink to this headline">¶</a></h4>
<p>Wait, wasn&#8217;t this called PyAudio-CFFI just a moment ago? Yes, since it
originally started out as a re-implementation of PyAudio using the
CFFI instead of a CPython extension. However, it quickly developed
into something different, which warrants a different name.</p>
</div>
</div>
</div>
</div>
<div class="section" id="module-pysoundio">
<span id="module-documentation"></span><h1>Module Documentation<a class="headerlink" href="#module-pysoundio" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pysoundio.Stream">
<em class="property">class </em><tt class="descclassname">pysoundio.</tt><tt class="descname">Stream</tt><big>(</big><em>sample_rate=44100</em>, <em>block_length=1024</em>, <em>input_device=True</em>, <em>output_device=True</em>, <em>callback=None</em>, <em>finished_callback=None</em>, <em>**flags</em><big>)</big><a class="headerlink" href="#pysoundio.Stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Streams handle audio input and output to your application.</p>
<p>Each stream operates at a specific sample rate with specific
sample formats and buffer sizes. Each stream can either be half
duplex (input only or output only) or full duplex (both input and
output). For full duplex operation, the input and output device
must use the same audio api.</p>
<p>Once a stream has been created, audio processing can be started
and stopped multiple times using start(), stop() and abort(). The
functions is_active() and is_stopped() can be used to check this.</p>
<p>The functions info(), time() and cpu_load() can be used to get
additional information about the stream.</p>
<p>Data can be read and written to the stream using read() and
write(). Use read_length() and write_length() to see how many
frames can be read or written at the current time.</p>
<p>Alternatively, a callback can be specified which is called
whenever there is data available to read or write.</p>
<dl class="method">
<dt id="pysoundio.Stream.abort">
<tt class="descname">abort</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate audio processing immediately.</p>
<p>This does not wait for pending audio buffers. If successful,
the stream is considered inactive.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.cpu_load">
<tt class="descname">cpu_load</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.cpu_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve CPU usage information for the specified stream.</p>
<p>A floating point number between 0.0 and 1.0 that is a fraction
of the total CPU time consumed by the stream callback audio
processing within portaudio. This excludes time spent in the
cffi and Python. This function does not work with blocking
read/write streams.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve unchanging information about the open stream.</p>
<p>Returns a dictionary containing four fields:</p>
<p>struct_version: Always 1</p>
<p>input_latency: The most accurate estimate of the input latency
of the stream in seconds. The value will be zero for
output-only streams.</p>
<p>output_latency: The most accurate estimate of the output
latency of the stream in seconds. The value will be zero for
input-only streams.</p>
<p>sample_rate: The sample rate of the stream in Hz. In cases
where the hardware sample rate is inaccurate and portaudio is
aware of it, the value of this field may be different from the
sample_rate parameter passed to the stream constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.is_active">
<tt class="descname">is_active</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the stream is active.</p>
<p>A stream is active after a successful call to start(). It
becomes inactive as a result to stop() or abort() or a return
value other than continue from the stream callback.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.is_stopped">
<tt class="descname">is_stopped</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.is_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a stream is stopped.</p>
<p>A stream is stopped before the first call to start() and after
a successful call to stop() or abort(). If the stream callback
returns a value other than continue, the stream is NOT
considered stopped.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.read">
<tt class="descname">read</tt><big>(</big><em>num_frames=1024</em>, <em>raw=False</em><big>)</big><a class="headerlink" href="#pysoundio.Stream.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read samples from an input stream.</p>
<p>The function does not return until the required number of
frames has been read. This may involve waiting for the
operating system to supply the data.</p>
<p>If raw data is requested, the raw cffi data buffer is
returned. Otherwise, a numpy array of the appropriate dtype
with one column per channel is returned.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.read_length">
<tt class="descname">read_length</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.read_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of frames that can be written without waiting.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Commence audio processing.</p>
<p>If successful, the stream is considered active.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate audio processing.</p>
<p>This waits until all pending audio buffers have been played
before it returns. If successful, the stream is considered
inactive.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.time">
<tt class="descname">time</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current stream time in seconds.</p>
<p>This is the same time that is given to the stream callback. It
is monotonically increasing and is not affected by starting or
stopping the stream. This time may be used for synchronizing
other events to the audio stream.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.write">
<tt class="descname">write</tt><big>(</big><em>data</em>, <em>num_frames=None</em><big>)</big><a class="headerlink" href="#pysoundio.Stream.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write samples to an output stream.</p>
<p>The functino does not return until the required number of
frames has been written. This may involve waiting for the
operating system to consume the data.</p>
<p>The data can either be supplied as a numpy array, a list, or
as raw bytes. Numpy arrays and lists will be automatically
converted to the appropriate data type and the number of
frames will be inferred from the array length. Data for
different channels should be supplied in different columns.</p>
</dd></dl>

<dl class="method">
<dt id="pysoundio.Stream.write_length">
<tt class="descname">write_length</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.Stream.write_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of frames that can be read without waiting.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pysoundio.apis">
<tt class="descclassname">pysoundio.</tt><tt class="descname">apis</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.apis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all available audio apis.</p>
</dd></dl>

<dl class="function">
<dt id="pysoundio.default_api">
<tt class="descclassname">pysoundio.</tt><tt class="descname">default_api</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.default_api" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns data about the default audio api.</p>
</dd></dl>

<dl class="function">
<dt id="pysoundio.default_input_device">
<tt class="descclassname">pysoundio.</tt><tt class="descname">default_input_device</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.default_input_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns data about the default audio input device.</p>
</dd></dl>

<dl class="function">
<dt id="pysoundio.default_output_device">
<tt class="descclassname">pysoundio.</tt><tt class="descname">default_output_device</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.default_output_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns data about the default audio output device.</p>
</dd></dl>

<dl class="function">
<dt id="pysoundio.devices">
<tt class="descclassname">pysoundio.</tt><tt class="descname">devices</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.devices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all available audio devices.</p>
</dd></dl>

<dl class="function">
<dt id="pysoundio.pa_version">
<tt class="descclassname">pysoundio.</tt><tt class="descname">pa_version</tt><big>(</big><big>)</big><a class="headerlink" href="#pysoundio.pa_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the version information about the portaudio library.</p>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">PySoundIO 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Bastian Bechtold.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>